using {ProjectName}.Core.Contracts.Aggregates.{Pluralize}.CommandRepositories;
using {ProjectName}.Core.Contracts.Aggregates.{Pluralize}.Commands;
using {ProjectName}.Core.Domain.Aggregates.{Pluralize};

using FluentResults;

using MDF.Framework.LayersContracts.ApplicationServices.MediatorExtensions.CQRS;
using MDF.Resources.Common.FormattedMessages;
using Microsoft.Extensions.Logging;

namespace {ProjectName}.Core.ApplicationService.Aggregates.{Pluralize}.CommandHandlers;
public class Create{Singular}CommandHandler : ICommandHandler<Create{Singular}Command, Guid>
{
	private readonly I{Singular}CommandRepository _{SingularVar}CommandRepository;
	private readonly ILogger<Create{Singular}CommandHandler> _logger;
	public Create{Singular}CommandHandler(I{Singular}CommandRepository {SingularVar}CommandRepository, ILogger<Create{Singular}CommandHandler> logger)
	{
		_{SingularVar}CommandRepository = {SingularVar}CommandRepository;
		_logger = logger;
	}

	public async Task<Result<Guid>> Handle(Create{Singular}Command request, CancellationToken cancellationToken)
	{
		var category = new {Singular}()
			.Create{Singular}(request.Title);
		if (category.Result.IsSuccess)
		{
			await _{SingularVar}CommandRepository.InsertByAsync(category, cancellationToken);
			await _{SingularVar}CommandRepository.CommitAsync(cancellationToken);
			return category.Id;
		}
		return Result.Fail(ErrorMessages.UnexpectedError);
	}
}
